<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ConnectingSPFM" xml:space="preserve">
    <value>SCCIで物理音源に接続しています...</value>
  </data>
  <data name="UpdatingADPCM" xml:space="preserve">
    <value>ADPCMデータを更新中...</value>
  </data>
  <data name="UpdatingPCM" xml:space="preserve">
    <value>PCMデータを更新中...</value>
  </data>
  <data name="AdpcmBufferExceeded" xml:space="preserve">
    <value>ADPCM バッファが溢れました。</value>
  </data>
  <data name="AdpcmBufferUsed" xml:space="preserve">
    <value>ADPCM バッファを {0}/256 KB 使っています。</value>
  </data>
  <data name="FailedLoadFile" xml:space="preserve">
    <value>ファイルの読み込みに失敗しました。</value>
  </data>
  <data name="FailedLoadMAmi" xml:space="preserve">
    <value>MAmiファイルの読み込みに失敗しました。</value>
  </data>
  <data name="FailedLoadMAmidi" xml:space="preserve">
    <value>MAmidiファイルの読み込みに失敗しました。</value>
  </data>
  <data name="FailedLoadMidi" xml:space="preserve">
    <value>MIDIファイルの読み込みに失敗しました。</value>
  </data>
  <data name="FailedMidiIf" xml:space="preserve">
    <value>MIDIインターフェースの設定に失敗しました。</value>
  </data>
  <data name="FailedSaveEnv" xml:space="preserve">
    <value>現在の環境の保存に失敗しました。</value>
  </data>
  <data name="FailedSaveMAmidi" xml:space="preserve">
    <value>現在の環境とMIDIデータのMAmidiファイルへの保存に失敗しました。</value>
  </data>
  <data name="LoadMidiFile" xml:space="preserve">
    <value>現在の環境とMIDIデータのMAmidiファイルへの保存するには、MIDIファイルを読み込んでください。</value>
  </data>
  <data name="WanrSPC700SampleLength" xml:space="preserve">
    <value>いくつかの音のサンプル長が16の倍数でないため、おかしくなる可能性があります。</value>
  </data>
  <data name="FailedLaunch" xml:space="preserve">
    <value>起動に失敗しました。</value>
  </data>
  <data name="ImportSF2Drum" xml:space="preserve">
    <value>SF2ファイルからPCMを&amp;DrumTimbresへインポートする....</value>
  </data>
  <data name="ImportSF2Timbre" xml:space="preserve">
    <value>SF2ファイルからPCMを&amp;Timbresへインポートする....</value>
  </data>
  <data name="ClearAllInsts" xml:space="preserve">
    <value>全ての音源をクリアしますか？</value>
  </data>
  <data name="CNTWarning" xml:space="preserve">
    <value>4OPで音を出力する場合、Chip(Global) -&gt; CONSEL プロパティの値を1またはそれ以上にしないと音がなりません。</value>
  </data>
  <data name="NoMidiPort" xml:space="preserve">
    <value>MIDI IN デバイスがありません。
MAmidiMEmo の機能をすべて利用する場合、 MIDI IN デバイスまたは loopMIDI アプリをインストールする必要があります。</value>
  </data>
  <data name="RestartConfirmation" xml:space="preserve">
    <value>新しい設定を反映するため再起動しますか？</value>
  </data>
  <data name="SampleRate" xml:space="preserve">
    <value>MAmidiMEmoのサンプリング周波数はMAmidiMEmo起動時のDAWのサンプリング周波数に従います。</value>
  </data>
  <data name="DpcmBufferExceeded" xml:space="preserve">
    <value>DPCM バッファが溢れました。</value>
  </data>
  <data name="DpcmBufferUsed" xml:space="preserve">
    <value>ADPCM バッファを {0} bytes 使っています。</value>
  </data>
  <data name="UpdatingDPCM" xml:space="preserve">
    <value>DPCMデータを更新中...</value>
  </data>
  <data name="ImportSpcDrum" xml:space="preserve">
    <value>S&amp;PCファイルからPCMをDrumTimbresへインポートする...</value>
  </data>
  <data name="ImportSpcTimbre" xml:space="preserve">
    <value>&amp;SPCファイルからPCMをTimbresへインポートする...</value>
  </data>
  <data name="TimbreLoaded" xml:space="preserve">
    <value>{0} 個の Timbre を読み込みました。</value>
  </data>
  <data name="CopiedVSTi" xml:space="preserve">
    <value>MAmi VSTi が DAW のプラグインフォルダにコピーされました。</value>
  </data>
  <data name="SelectDAWFolder" xml:space="preserve">
    <value>DAW のプラグインフォルダを選択してください</value>
  </data>
  <data name="ConnectingGimic" xml:space="preserve">
    <value>c86ctlで物理音源GIMICに接続しています...</value>
  </data>
  <data name="WsgMorphError1" xml:space="preserve">
    <value>最後の項目以外を選択してください。</value>
  </data>
  <data name="WsgMorphTitle" xml:space="preserve">
    <value>追加する項目数を入力してください。</value>
  </data>
  <data name="AdpcmBufferUsedSPC700" xml:space="preserve">
    <value>ADPCM バッファを {0}/63 KB 使っています。</value>
  </data>
  <data name="ConfirmConvertSampleRate" xml:space="preserve">
    <value>サンプリング周波数を {0}Hz として読み込みますか？
(選択は記憶します。再起動するかAltキーを押しながらファイルを選択すると再確認します)</value>
  </data>
  <data name="ContinuousSet" xml:space="preserve">
    <value>連番を設定する個数を指定してください。</value>
  </data>
  <data name="ContinuousSetError" xml:space="preserve">
    <value>TimbreNumberが設定されている項目を選択してください。</value>
  </data>
  <data name="SampleRateOver" xml:space="preserve">
    <value>サンプリング周波数が {0}Hz を超えています.</value>
  </data>
  <data name="TimbreList" xml:space="preserve">
    <value>音色リスト(&amp;L)</value>
  </data>
</root>